# TAP results for test_keyboard_interrupt.py
not ok 1 - test_keyboard_interrupt.py::test_foobar
# 
#     def test_foobar():
# >       assert 0
# E       assert 0
# 
# test_keyboard_interrupt.py:2: AssertionError
not ok 2 - test_keyboard_interrupt.py::test_spamegg
# 
#     def test_spamegg():
# >       import py; pytest.skip('skip me please!')
# E       NameError: global name 'pytest' is not defined
# 
# test_keyboard_interrupt.py:4: NameError
not ok 3 - test_keyboard_interrupt.py::test_foobar
# 
#     def test_foobar():
# >       assert 0
# E       assert 0
# 
# test_keyboard_interrupt.py:2: AssertionError
not ok 4 - test_keyboard_interrupt.py::test_spamegg
# 
#     def test_spamegg():
# >       import py; pytest.skip('skip me please!')
# E       NameError: global name 'pytest' is not defined
# 
# test_keyboard_interrupt.py:4: NameError
not ok 5 - test_keyboard_interrupt.py::test_foobar
# 
#     def test_foobar():
# >       assert 0
# E       assert 0
# 
# test_keyboard_interrupt.py:2: AssertionError
not ok 6 - test_keyboard_interrupt.py::test_spamegg
# 
#     def test_spamegg():
# >       import py; pytest.skip('skip me please!')
# E       NameError: global name 'pytest' is not defined
# 
# test_keyboard_interrupt.py:4: NameError
not ok 7 - test_keyboard_interrupt.py::test_foobar
# 
# self = <CallInfo when='call' exception: assert 0>
# func = <function <lambda> at 0x7fa0116ef230>, when = 'call'
# 
#     def __init__(self, func, when):
#         #: context of invocation: one of "setup", "call",
#         #: "teardown", "memocollect"
#         self.when = when
#         self.start = time()
#         try:
# >           self.result = func()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:192: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   return CallInfo(lambda: ihook(item=item, **kwds), when=when)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:178: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_HookCaller 'pytest_runtest_call'>, args = ()
# kwargs = {'item': <Function 'test_foobar'>}, notincall = set([])
# 
#     def __call__(self, *args, **kwargs):
#         if args:
#             raise TypeError("hook calling supports only keyword arguments")
#         assert not self.is_historic()
#         if self.argnames:
#             notincall = set(self.argnames) - set(['__multicall__']) - set(
#                 kwargs.keys())
#             if notincall:
#                 warnings.warn(
#                     "Argument(s) {} which are declared in the hookspec "
#                     "can not be found in this hook call"
#                     .format(tuple(notincall)),
#                     stacklevel=2,
#                 )
# >       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:617: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_pytest.config.PytestPluginManager object at 0x7fa01099e750>
# hook = <_HookCaller 'pytest_runtest_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_foobar'>}
# 
#     def _hookexec(self, hook, methods, kwargs):
#         # called from all hookcaller instances.
#         # enable_tracing will set its own wrapping function at self._inner_hookexec
# >       return self._inner_hookexec(hook, methods, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:222: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <pluggy._TracedHookExecution object at 0x7fa010f66810>
# hook = <_HookCaller 'pytest_runtest_call'>
# hook_impls = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_foobar'>}
# 
#     def __call__(self, hook, hook_impls, kwargs):
#         self.before(hook.name, hook_impls, kwargs)
#         outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
#         self.after(outcome, hook.name, hook_impls, kwargs)
# >       return outcome.get_result()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:182: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:180: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# hook = <_HookCaller 'pytest_runtest_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_foobar'>}
# 
#     self._inner_hookexec = lambda hook, methods, kwargs: \
#         hook.multicall(
#             methods, kwargs,
# >           firstresult=hook.spec_opts.get('firstresult'),
#         )
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:216: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# item = <Function 'test_foobar'>
# 
#     def pytest_runtest_call(item):
#         _update_current_test_var(item, 'call')
#         try:
# >           item.runtest()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:109: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <Function 'test_foobar'>
# 
#     def runtest(self):
#         """ execute the underlying test function. """
# >       self.ihook.pytest_pyfunc_call(pyfuncitem=self)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/python.py:1179: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
# kwargs = {'pyfuncitem': <Function 'test_foobar'>}, notincall = set([])
# 
#     def __call__(self, *args, **kwargs):
#         if args:
#             raise TypeError("hook calling supports only keyword arguments")
#         assert not self.is_historic()
#         if self.argnames:
#             notincall = set(self.argnames) - set(['__multicall__']) - set(
#                 kwargs.keys())
#             if notincall:
#                 warnings.warn(
#                     "Argument(s) {} which are declared in the hookspec "
#                     "can not be found in this hook call"
#                     .format(tuple(notincall)),
#                     stacklevel=2,
#                 )
# >       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:617: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_pytest.config.PytestPluginManager object at 0x7fa01099e750>
# hook = <_HookCaller 'pytest_pyfunc_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_foobar'>}
# 
#     def _hookexec(self, hook, methods, kwargs):
#         # called from all hookcaller instances.
#         # enable_tracing will set its own wrapping function at self._inner_hookexec
# >       return self._inner_hookexec(hook, methods, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:222: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <pluggy._TracedHookExecution object at 0x7fa010f66810>
# hook = <_HookCaller 'pytest_pyfunc_call'>
# hook_impls = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_foobar'>}
# 
#     def __call__(self, hook, hook_impls, kwargs):
#         self.before(hook.name, hook_impls, kwargs)
#         outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
#         self.after(outcome, hook.name, hook_impls, kwargs)
# >       return outcome.get_result()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:182: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:180: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# hook = <_HookCaller 'pytest_pyfunc_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_foobar'>}
# 
#     self._inner_hookexec = lambda hook, methods, kwargs: \
#         hook.multicall(
#             methods, kwargs,
# >           firstresult=hook.spec_opts.get('firstresult'),
#         )
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:216: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# pyfuncitem = <Function 'test_foobar'>
# 
#     @hookimpl(trylast=True)
#     def pytest_pyfunc_call(pyfuncitem):
#         testfunction = pyfuncitem.obj
#         if pyfuncitem._isyieldedfunction():
#             testfunction(*pyfuncitem._args)
#         else:
#             funcargs = pyfuncitem.funcargs
#             testargs = {}
#             for arg in pyfuncitem._fixtureinfo.argnames:
#                 testargs[arg] = funcargs[arg]
# >           testfunction(**testargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/python.py:155: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
#     def test_foobar():
# >       assert 0
# E       assert 0
# 
# test_keyboard_interrupt.py:2: AssertionError
not ok 8 - test_keyboard_interrupt.py::test_spamegg
# 
# self = <CallInfo when='call' exception: global name 'pytest' is not defined>
# func = <function <lambda> at 0x7fa0116efb18>, when = 'call'
# 
#     def __init__(self, func, when):
#         #: context of invocation: one of "setup", "call",
#         #: "teardown", "memocollect"
#         self.when = when
#         self.start = time()
#         try:
# >           self.result = func()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:192: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   return CallInfo(lambda: ihook(item=item, **kwds), when=when)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:178: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_HookCaller 'pytest_runtest_call'>, args = ()
# kwargs = {'item': <Function 'test_spamegg'>}, notincall = set([])
# 
#     def __call__(self, *args, **kwargs):
#         if args:
#             raise TypeError("hook calling supports only keyword arguments")
#         assert not self.is_historic()
#         if self.argnames:
#             notincall = set(self.argnames) - set(['__multicall__']) - set(
#                 kwargs.keys())
#             if notincall:
#                 warnings.warn(
#                     "Argument(s) {} which are declared in the hookspec "
#                     "can not be found in this hook call"
#                     .format(tuple(notincall)),
#                     stacklevel=2,
#                 )
# >       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:617: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_pytest.config.PytestPluginManager object at 0x7fa01099e750>
# hook = <_HookCaller 'pytest_runtest_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_spamegg'>}
# 
#     def _hookexec(self, hook, methods, kwargs):
#         # called from all hookcaller instances.
#         # enable_tracing will set its own wrapping function at self._inner_hookexec
# >       return self._inner_hookexec(hook, methods, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:222: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <pluggy._TracedHookExecution object at 0x7fa010f66810>
# hook = <_HookCaller 'pytest_runtest_call'>
# hook_impls = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_spamegg'>}
# 
#     def __call__(self, hook, hook_impls, kwargs):
#         self.before(hook.name, hook_impls, kwargs)
#         outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
#         self.after(outcome, hook.name, hook_impls, kwargs)
# >       return outcome.get_result()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:182: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:180: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# hook = <_HookCaller 'pytest_runtest_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498050>, <pluggy.HookImpl object at 0x7fa011c0c510>, <pluggy.HookImpl object at 0x7fa011c0c590>, <pluggy.HookImpl object at 0x7fa010e771d0>]
# kwargs = {'item': <Function 'test_spamegg'>}
# 
#     self._inner_hookexec = lambda hook, methods, kwargs: \
#         hook.multicall(
#             methods, kwargs,
# >           firstresult=hook.spec_opts.get('firstresult'),
#         )
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:216: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# item = <Function 'test_spamegg'>
# 
#     def pytest_runtest_call(item):
#         _update_current_test_var(item, 'call')
#         try:
# >           item.runtest()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/runner.py:109: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <Function 'test_spamegg'>
# 
#     def runtest(self):
#         """ execute the underlying test function. """
# >       self.ihook.pytest_pyfunc_call(pyfuncitem=self)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/python.py:1179: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
# kwargs = {'pyfuncitem': <Function 'test_spamegg'>}, notincall = set([])
# 
#     def __call__(self, *args, **kwargs):
#         if args:
#             raise TypeError("hook calling supports only keyword arguments")
#         assert not self.is_historic()
#         if self.argnames:
#             notincall = set(self.argnames) - set(['__multicall__']) - set(
#                 kwargs.keys())
#             if notincall:
#                 warnings.warn(
#                     "Argument(s) {} which are declared in the hookspec "
#                     "can not be found in this hook call"
#                     .format(tuple(notincall)),
#                     stacklevel=2,
#                 )
# >       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:617: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <_pytest.config.PytestPluginManager object at 0x7fa01099e750>
# hook = <_HookCaller 'pytest_pyfunc_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_spamegg'>}
# 
#     def _hookexec(self, hook, methods, kwargs):
#         # called from all hookcaller instances.
#         # enable_tracing will set its own wrapping function at self._inner_hookexec
# >       return self._inner_hookexec(hook, methods, kwargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:222: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# self = <pluggy._TracedHookExecution object at 0x7fa010f66810>
# hook = <_HookCaller 'pytest_pyfunc_call'>
# hook_impls = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_spamegg'>}
# 
#     def __call__(self, hook, hook_impls, kwargs):
#         self.before(hook.name, hook_impls, kwargs)
#         outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
#         self.after(outcome, hook.name, hook_impls, kwargs)
# >       return outcome.get_result()
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:182: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# >   outcome = _Result.from_call(lambda: self.oldcall(hook, hook_impls, kwargs))
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:180: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# hook = <_HookCaller 'pytest_pyfunc_call'>
# methods = [<pluggy.HookImpl object at 0x7fa010498c90>, <pluggy.HookImpl object at 0x7fa011e87c10>]
# kwargs = {'pyfuncitem': <Function 'test_spamegg'>}
# 
#     self._inner_hookexec = lambda hook, methods, kwargs: \
#         hook.multicall(
#             methods, kwargs,
# >           firstresult=hook.spec_opts.get('firstresult'),
#         )
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/pluggy/__init__.py:216: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
# pyfuncitem = <Function 'test_spamegg'>
# 
#     @hookimpl(trylast=True)
#     def pytest_pyfunc_call(pyfuncitem):
#         testfunction = pyfuncitem.obj
#         if pyfuncitem._isyieldedfunction():
#             testfunction(*pyfuncitem._args)
#         else:
#             funcargs = pyfuncitem.funcargs
#             testargs = {}
#             for arg in pyfuncitem._fixtureinfo.argnames:
#                 testargs[arg] = funcargs[arg]
# >           testfunction(**testargs)
# 
# /home/sergeyb/Downloads/pytest/pip/local/lib/python2.7/site-packages/_pytest/python.py:155: 
# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
# 
#     def test_spamegg():
# >       import py; pytest.skip('skip me please!')
# E       NameError: global name 'pytest' is not defined
# 
# test_keyboard_interrupt.py:4: NameError
1..8
